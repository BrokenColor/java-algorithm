package algorithmCode.InterestingCode;

import java.util.ArrayDeque;
import java.util.HashMap;
import java.util.Map;
import java.util.Queue;

/**
 * 924.尽量减少恶意软件的传播
 *
 * @Author bc
 * @Date 2024/4/16 23:44
 * @Description: 数组，图，广度优先
 */
public class LC_924_H_minMalwareSpread {

    public static void main(String[] args) {
        int[][] graph = {{1, 1, 0}, {1, 1, 0}, {0, 0, 1}};
        int[] initial = {0, 1};
        LC_924_H_minMalwareSpread solution = new LC_924_H_minMalwareSpread();
        System.out.println(solution.minMalwareSpread(graph, initial));
    }

    /**
     * 找出在给定图中，从初始病毒源开始传播时，最小可能被感染的软件数量。
     *
     * @param graph   二维数组表示软件之间的连接情况，graph[i][j]为1表示软件i能感染软件j，为0则表示不能。
     * @param initial 一个数组，包含初始被病毒感染的软件的索引。
     * @return 返回一个软件索引，该软件是在删除病毒软件后的最小可能感染软件数量的候选软件。
     */
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length; // 软件数量
        int[] ids = new int[n]; // 用于标记软件所属的连通分量
        Map<Integer, Integer> idToSize = new HashMap<>(); // 记录每个连通分量的大小（被感染软件数量）
        int id = 0; // 连通分量的唯一标识符
        // 标记连通分量并计算其大小
        for (int i = 0; i < n; i++) {
            if (ids[i] == 0) {
                id++;
                int size = 1; // 当前连通分量的大小
                Queue<Integer> queue = new ArrayDeque<>(); // 广度优先搜索用队列
                queue.offer(i);
                ids[i] = id;
                while (!queue.isEmpty()) {
                    Integer u = queue.poll();
                    for (int j = 0; j < n; j++) {
                        if (ids[j] == 0 && graph[u][j] == 1) {
                            size++;
                            queue.offer(j);
                            ids[j] = id;
                        }
                    }
                }
                idToSize.put(id, size);
            }
        }
        Map<Integer, Integer> idToInitial = new HashMap<>(); // 记录初始被感染的软件属于哪个连通分量以及其数量
        for (int u : initial) {
            idToInitial.put(ids[u], idToInitial.getOrDefault(ids[u], 0) + 1);
        }
        int ans = n + 1; // 记录最小可能感染软件数量，初始化为一个超过可能范围的值
        int ansRemoved = 0; // 记录对应ans时删除的软件数量
        // 遍历初始被感染的软件，找出删除后可能感染的软件最小的软件
        for (int u : initial) {
            int removed = idToInitial.get(ids[u]) == 1 ? idToSize.get(ids[u]) : 0;
            if (removed > ansRemoved || (removed == ansRemoved && ans > u)) {
                ans = u;
                ansRemoved = removed;
            }
        }
        return ans;
    }
}
