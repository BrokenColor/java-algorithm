package algorithmCode.InterestingCode;

import java.util.ArrayList;
import java.util.List;

/**
 * 928. 尽量减少恶意软件的传播 II
 *
 * @Author bc
 * @Date 2024/4/17 23:42
 * @Description: TODO
 */
public class LC_928_H_minMalwareSpread {

    public static void main(String[] args) {
//        int[][] graph = {{1, 1, 0}, {1, 1, 0}, {0, 0, 1}};
        int[][] graph = {{1, 1, 0}, {1, 1, 1}, {0, 1, 1}};
        int[] initial = {0, 1};
        LC_928_H_minMalwareSpread solution = new LC_928_H_minMalwareSpread();
        System.out.println(solution.minMalwareSpread(graph, initial));
    }

    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        boolean[] initialSet = new boolean[n];
        for (int v : initial) {
            initialSet[v] = true;
        }
        List<Integer>[] initialBy = new List[n];
        for (int i = 0; i < n; i++) {
            initialBy[i] = new ArrayList<>();
        }
        for (int v : initial) {
            boolean[] infectedSet = new boolean[n];
            dfs(graph, initialSet, infectedSet, v);
            for (int j = 0; j < n; j++) {
                if (infectedSet[j]) {
                    initialBy[j].add(v);
                }
            }
        }
        int[] count = new int[n];
        for (int i = 0; i < n; i++) {
            if (initialBy[i].size() == 1) {
                count[initialBy[i].get(0)]++;
            }
        }

        int res = initial[0];
        for (int v : initial) {
            if (count[v] > count[res] || count[v] == count[res] && v < res) {
                res = v;
            }
        }
        return res;
    }

    /**
     * 深度优先搜索算法来传播感染状态。
     *
     * @param graph       表示节点之间关系的图，graph[v][i] 表示节点 v 到节点 i 的连接状态（0 表示未连接，1 表示连接）。
     * @param initialSet  初始感染集合，标记哪些节点最初被感染。
     * @param infectedSet 记录感染集合，随着算法的进行，将逐渐记录被感染的节点。
     * @param v           当前正在处理的节点。
     */
    public void dfs(int[][] graph, boolean[] initialSet, boolean[] infectedSet, int v) {
        int n = graph.length; // 图中节点的数量
        for (int i = 0; i < n; i++) { // 遍历所有节点
            // 如果节点之间没有连接，或者已经被感染，或者初始时已被感染，则跳过当前循环
            if (graph[v][i] == 0 || initialSet[i] || infectedSet[i]) {
                continue;
            }
            // 将当前节点标记为初始感染状态，并递归地对相邻未感染节点进行深度优先搜索
            initialSet[i] = true;
            dfs(graph, initialSet, infectedSet, i);
        }
    }
}
