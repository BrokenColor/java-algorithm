package algorithmCode.InterestingCode;

import java.util.ArrayList;
import java.util.List;

/**
 * 928. 尽量减少恶意软件的传播 II
 *
 * @Author bc
 * @Date 2024/4/17 23:42
 * @Description: TODO
 */
public class LC_928_H_minMalwareSpread {

    public static void main(String[] args) {
//        int[][] graph = {{1, 1, 0}, {1, 1, 0}, {0, 0, 1}};
        int[][] graph = {{1, 1, 0}, {1, 1, 1}, {0, 1, 1}};
        int[] initial = {0, 1};
        LC_928_H_minMalwareSpread solution = new LC_928_H_minMalwareSpread();
        System.out.println(solution.minMalwareSpread(graph, initial));
    }

    /**
     * 计算最小恶意软件传播。
     *
     * @param graph   表示节点之间感染关系的二维数组。graph[i][j] 为 1 表示节点 i 可以感染节点 j，为 0 表示不能。
     * @param initial 初始被感染的节点数组。
     * @return 返回在移除一个节点后，能够最小化恶意软件传播的节点。
     */
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length; // 节点数量
        boolean[] initialSet = new boolean[n]; // 用于标记初始被感染的节点
        for (int v : initial) {
            initialSet[v] = true;
        }

        List<Integer>[] infectedBy = new List[n]; // infectedBy[u] 存储能够感染节点 u 的节点列表
        for (int i = 0; i < n; i++) {
            infectedBy[i] = new ArrayList();
        }

        // 遍历初始被感染的节点，用深度优先搜索找出所有可被感染的节点
        for (int v : initial) {
            boolean[] infectedSet = new boolean[n]; // 用于标记已被感染的节点
            dfs(graph, initialSet, infectedSet, v);
            for (int u = 0; u < n; u++) {
                if (infectedSet[u]) {
                    infectedBy[u].add(v);
                }
            }
        }

        int[] count = new int[n]; // 计算每个节点能感染的其他节点数量
        for (int i = 0; i < n; i++) {
            if (infectedBy[i].size() == 1) {
                count[infectedBy[i].get(0)]++;
            }
        }

        int res = initial[0]; // 初始化结果为初始感染节点中的第一个节点
        // 找出在剩余的初始感染节点中，能够感染其他节点数量最少的节点（如果有多个，则选择编号最小的）
        for (int v : initial) {
            if (count[v] > count[res] || count[v] == count[res] && v < res) {
                res = v;
            }
        }
        return res; // 返回结果
    }

    /**
     * 深度优先搜索算法（DFS）用于遍历或搜索树或图。这里被用于感染的传播模拟。
     *
     * @param graph       表示图的邻接矩阵，graph[v][u]为1表示节点v可以感染节点u，为0则表示不能。
     * @param initialSet 初始感染集合，标记了初始被感染的节点。
     * @param infectedSet 记录感染集合，随着算法的进行，记录下被感染的节点。
     * @param v          当前正在处理的节点。
     */
    public void dfs(int[][] graph, boolean[] initialSet, boolean[] infectedSet, int v) {
        int n = graph.length; // 图中节点的数量
        for (int i = 0; i < n; i++) { // 遍历所有可能的邻居节点
            // 如果节点u不可达，已经被感染或初始时已被感染，则跳过
            if (graph[v][i] == 0 || initialSet[i] || infectedSet[i]) {
                continue;
            }
            // 感染节点u
            infectedSet[i] = true;
            // 递归地继续深度优先搜索
            dfs(graph, initialSet, infectedSet, i);
        }
    }
}
